#include "basis.hpp"

Mat create_basis_autostride(MPI_Comm COMM, const floatvector2d& src_nodes,
                            const floatvector2d& tgt_nodes){

  if(tgt_nodes.size() != src_nodes.size())
  {
    throw std::runtime_error("src and dest must have same dimensionality");
  }
  
  // get shapes from node lists
  intvector tgt_shape(tgt_nodes.size());
  std::transform(tgt_nodes.begin(), tgt_nodes.end(), tgt_shape.begin(),
                 [](floatvector y) -> integer{return y.size();});
  integer n_nodes = std::accumulate(tgt_shape.begin(), tgt_shape.end(), 1, 
                                     std::multiplies<integer>());

  integer rank, num_ranks, mpi_err;
  mpi_err = MPI_Comm_rank(COMM, &rank);
  mpi_err = MPI_Comm_size(COMM, &num_ranks);

  integer rowsize = n_nodes / num_ranks;
  integer remainder = n_nodes % num_ranks;
  integer startrow = rowsize * rank;
  // take care of remainder
  if(rank < remainder){
    rowsize += 1;
    startrow += rank;
  } else {
    startrow += remainder;
  }
  integer endrow = startrow + rowsize;

  Mat basis = create_basis(COMM, src_nodes, tgt_nodes, startrow, endrow);

  return basis;
}

// NB if node spacings are not regular then behaviour is undefined.
Mat create_basis(MPI_Comm COMM, const floatvector2d& src_nodes, const floatvector2d& tgt_nodes,
                 integer startrow, integer endrow){

  integer ndim = src_nodes.size();
  if(tgt_nodes.size() != src_nodes.size())
  {
    throw std::runtime_error("src and dest must have same dimensionality");
  }
  
  // get shapes from node lists
  intvector src_shape(ndim);
  std::transform(src_nodes.begin(), src_nodes.end(), src_shape.begin(),
                 [](floatvector y) -> integer{return y.size();});
  intvector tgt_shape(ndim);
  std::transform(tgt_nodes.begin(), tgt_nodes.end(), tgt_shape.begin(),
                 [](floatvector y) -> integer{return y.size();});

  // will also need sizes
  integer src_size = std::accumulate(src_shape.begin(), src_shape.end(), 1,
                                     std::multiplies<integer>());
  integer tgt_size = std::accumulate(tgt_shape.begin(), tgt_shape.end(), 1,
                                     std::multiplies<integer>());

  // find transformation coefficients from tgt loc to src loc
  // Lambdas avoid structural complexity and namespace pollution
  auto get_scalecoeff = [](floatvector snod, floatvector tnod) -> floating{
    return (tnod[1] - tnod[0])/(snod[1] - snod[0]);};
  auto get_shiftcoeff = [](floatvector snod, floatvector tnod, floating scale) -> floating{
    return (tnod[0] - snod[0])/(snod[1] - snod[0]);};

  floatvector scale_coeffs(ndim), shift_coeffs(ndim);
  std::transform(src_nodes.begin(), src_nodes.end(), tgt_nodes.begin(), scale_coeffs.begin(),
                 get_scalecoeff);
  n_ary_transform(get_shiftcoeff, shift_coeffs.begin(), src_nodes.begin(), src_nodes.end(),
		  tgt_nodes.begin(), scale_coeffs.begin());

  // construct CSR format directly
  intvector idxn, idxm;
  floatvector mdat;
  integer rowptr = 0;
  idxn.push_back(rowptr);
  
  for(integer idx=startrow; idx<endrow; idx++)
  {
    // unravel tgt loc and find equivalent source loc
    intvector tgt_coord = unravel(idx, tgt_shape);
    floatvector src_coord(ndim);
    intvector src_coord_floor(ndim);
    // need both exact loc and floored loc
    n_ary_transform([](floating x, floating a, floating b) -> floating{return x*a + b;},
		       src_coord.begin(), tgt_coord.begin(), tgt_coord.end(),
                       scale_coeffs.begin(), shift_coeffs.begin());
    std::transform(src_coord.begin(), src_coord.end(), src_coord_floor.begin(),
                   [](floating x) -> integer{return static_cast<integer> (std::floor(x));});

    for(integer dim=0; dim<ndim; dim++){
      if(all_true(src_coord_floor.begin(), src_coord_floor.end(), src_shape.begin(),
                 src_shape.end(), std::less<integer>()) 
          && std::all_of(src_coord_floor.begin(), src_coord_floor.end(),
                         [](floating a) -> bool{return a >= 0;}))
      {
        floating coeff = calculate_basis_coefficient(src_coord.begin(), src_coord.end(),
                                                     src_coord_floor.begin());
        if(coeff > 0)
        {
          rowptr++;
          idxm.push_back(ravel(src_coord_floor, src_shape));
          mdat.push_back(coeff);
        }
      }
      src_coord_floor[dim] += 1;
      if(all_true(src_coord_floor.begin(), src_coord_floor.end(), src_shape.begin(),
                 src_shape.end(), std::less<void>()) 
          && std::all_of(src_coord_floor.begin(), src_coord_floor.end(),
                         [](floating a) -> bool{return a >= 0;}))
      {
        floating coeff = calculate_basis_coefficient(src_coord.begin(), src_coord.end(),
                                                     src_coord_floor.begin());
        if(coeff > 0)
        {
          rowptr++;
          idxm.push_back(ravel(src_coord_floor, src_shape));
          mdat.push_back(coeff);
        }
      }
      src_coord_floor[dim] -= 1;
    }
    idxn.push_back(rowptr);
  }
  Mat basis_mat;
  MatCreateMPIAIJWithArrays(COMM, idxn.size()-1, PETSC_DECIDE, tgt_size, src_size,
                            idxn.data(), idxm.data(), mdat.data(), &basis_mat);

  return basis_mat;
} 
